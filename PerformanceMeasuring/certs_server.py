#!/usr/bin/env python3
"""
certs_server.py
- POST /certs
- usa questi file in /certs: cert.pem, key.pem
- invoca generate_delegated_credential.go (path usato: /root/go/src/crypto/tls/generate_delegated_credential.go)
- legge dc.cred (binary) e dckey.pem, li base64-encoda e risponde con JSON
- stampa solo errori e timestamp di invio
"""
import os
import time
import json
import base64
import subprocess
import traceback
from flask import Flask, jsonify, request

app = Flask(__name__)

CERTS_DIR = "/certs"
CERT_PEM = os.path.join(CERTS_DIR, "cert.pem")
KEY_PEM = os.path.join(CERTS_DIR, "key.pem")
DC_CRED = os.path.join(CERTS_DIR, "dc.cred")
DC_KEY = os.path.join(CERTS_DIR, "dckey.pem")

# Percorso al tool Go (lasciato come quello fornito dai prof)
#GO_TOOL = "/root/go/src/crypto/tls/generate_delegated_credential.go"
# Percorso al tool Go (ora binario precompilato)
GO_TOOL = "/usr/local/bin/generate"

def now_ns():
    return time.time_ns()

@app.route("/certs", methods=["POST"])
def handle_certs():
    t2_1 = now_ns()
    print(f"[SERVER] /certs received. t2.1 = {t2_1} ns")

    # Check presence of cert.pem and key.pem (these should be created by Dockerfile/provisioning)
    if not (os.path.exists(CERT_PEM) and os.path.exists(KEY_PEM)):
        # Try simple fallback generation (non-DC enabling) to avoid hard crash, but prefer provisioning to create proper certs
        print(f"[SERVER] Error: missing {CERT_PEM} or {KEY_PEM}", flush=True)
        return jsonify({"error": "server certificate/key missing"}), 500

    # Remove old DC files if present (clean slate)
    try:
        if os.path.exists(DC_CRED):
            os.remove(DC_CRED)
        if os.path.exists(DC_KEY):
            os.remove(DC_KEY)
    except Exception as e:
        print("[SERVER] Warning removing old DC files:", e, flush=True)

    # Call Go tool to generate delegated credential
    t3_1 = now_ns()
    go_returncode = None
    go_stdout = ""
    go_stderr = ""
    try:
        p = subprocess.run(
           # ["go", "run", GO_TOOL,
            [GO_TOOL,
             "-cert-path", CERT_PEM,
             "-key-path", KEY_PEM,
             "-signature-scheme", "Ed25519",
             "-duration", "168h"],
            cwd=CERTS_DIR,
            capture_output=True,
            text=True,
            timeout=120
        )
        go_returncode = p.returncode
        go_stdout = p.stdout or ""
        go_stderr = p.stderr or ""
        if go_returncode != 0:
            # do not crash: we will try to read produced files or return stdout/stderr
            print("[SERVER] Go returned non-zero code:", go_returncode, flush=True)
            if go_stderr:
                print("[SERVER] go stderr (short):", go_stderr.splitlines()[:10], flush=True)
    except Exception as e:
        go_returncode = -1
        go_stderr = f"exception running go: {e}\n{traceback.format_exc()}"
        print("[SERVER] Exception running Go tool:", e, flush=True)

    t3_2 = now_ns()

    # Read dc.cred and dckey.pem generated by Go tool
    dc_cred_b64 = ""
    dc_key_b64 = ""
    try:
        with open(DC_CRED, "rb") as f:
            dc_cred_bin = f.read()
        dc_cred_b64 = base64.b64encode(dc_cred_bin).decode("ascii")
        print(f"[SERVER] Read dc.cred, size: {len(dc_cred_bin)} bytes")
    except Exception as e:
        print(f"[SERVER] Error reading {DC_CRED}: {e}", flush=True)

    try:
        with open(DC_KEY, "rb") as f:
            dc_key_bin = f.read()
        dc_key_b64 = base64.b64encode(dc_key_bin).decode("ascii")
        print(f"[SERVER] Read dckey.pem, size: {len(dc_key_bin)} bytes")
    except Exception as e:
        print(f"[SERVER] Error reading {DC_KEY}: {e}", flush=True)

    # Also provide the base cert.pem and key.pem
    try:
        if os.path.exists(CERT_PEM):
            with open(CERT_PEM, "rb") as f:
                cert_bin = f.read()
            cert_b64 = base64.b64encode(cert_bin).decode("ascii")
    except Exception as e:
        print(f"[SERVER] Error reading {CERT_PEM}: {e}", flush=True)

    try:
        if os.path.exists(KEY_PEM):
            with open(KEY_PEM, "rb") as f:
                key_bin = f.read()
            key_b64 = base64.b64encode(key_bin).decode("ascii")
    except Exception as e:
        print(f"[SERVER] Error reading {KEY_PEM}: {e}", flush=True)

    t2_2 = now_ns()
    # prepare response
    resp = {
        "t2.1_ns": t2_1,
        "t3.1_ns": t3_1,
        "t3.2_ns": t3_2,
        "t2.2_ns": t2_2,
        "go_returncode": go_returncode if go_returncode is not None else -999,
        "go_stdout_short": (go_stdout[:2000] if go_stdout else ""),
        "go_stderr_short": (go_stderr[:2000] if go_stderr else ""),
        "dc_cred_b64": dc_cred_b64,
        "dc_key_b64": dc_key_b64,
        "cert_b64": cert_b64,
        "key_b64": key_b64
    }

    print(f"[SERVER] Response sent. t2.2 = {t2_2} ns", flush=True)
    return (json.dumps(resp), 200, {"Content-Type": "application/json"})

if __name__ == "__main__":
    print("[SERVER] certs service listening on port 5000 (POST /certs)", flush=True)
    # Flask dev server is acceptable for testing inside Docker
    app.run(host="0.0.0.0", port=5000, debug=False)
